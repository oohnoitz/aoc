<!-- livebook:{"file_entries":[{"file":{"file_system_id":"local","file_system_type":"local","path":"/data/aoc/2023/input/day01-p1t.txt"},"name":"day01-p1t.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/data/aoc/2023/input/day01-p2t.txt"},"name":"day01-p2t.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/data/aoc/2023/input/day01.txt"},"name":"day01.txt","type":"file"}]} -->

# AoC 2023 - Day 01

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

## Part One

```elixir
input_p1t =
  "day01-p1t.txt"
  |> Kino.FS.file_path()
  |> File.read!()
  |> String.trim()
```

```elixir
input =
  "day01.txt"
  |> Kino.FS.file_path()
  |> File.read!()
  |> String.trim()
```

```elixir
defmodule PartA do
  def solve(input) do
    input
    |> String.replace(~r/([A-Za-z])/, "")
    |> String.split("\n")
    |> Enum.map(&String.codepoints/1)
    |> Enum.map(&(List.first(&1) <> List.last(&1)))
    |> Enum.map(&String.to_integer/1)
    |> Enum.sum()
  end
end
```

```elixir
PartA.solve(input_p1t)
```

```elixir
PartA.solve(input)
```

## Part Two

```elixir
input_p2t =
  "day01-p2t.txt"
  |> Kino.FS.file_path()
  |> File.read!()
  |> String.trim()
```

```elixir
defmodule PartB do
  @mapping %{
    "1" => 1,
    "2" => 2,
    "3" => 3,
    "4" => 4,
    "5" => 5,
    "6" => 6,
    "7" => 7,
    "8" => 8,
    "9" => 9,
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "four" => 4,
    "five" => 5,
    "six" => 6,
    "seven" => 7,
    "eight" => 8,
    "nine" => 9
  }

  def solve(input) do
    input
    |> String.split("\n")
    |> Enum.map(&digit/1)
    |> Enum.map(&(List.first(&1) * 10 + List.last(&1)))
    |> Enum.sum()
  end

  def solve_regex(input) do
    input
    |> String.split("\n")
    |> Enum.map(&Regex.scan(~r/(?=(\d|one|two|three|four|five|six|seven|eight|nine))/, &1))
    |> Enum.map(&Enum.map(&1, fn [_a, b] -> Map.get(@mapping, b) end))
    |> Enum.map(&(List.first(&1) * 10 + List.last(&1)))
    |> Enum.sum()
  end

  def digit(input, acc \\ []) do
    case String.next_codepoint(input) do
      nil -> acc
      {_discard, string} -> digit(string, Enum.concat(acc, digit_mapping(input)))
    end
  end

  def digit_mapping(string) do
    for {digit, value} <- @mapping, String.starts_with?(string, digit) do
      value
    end
  end
end
```

```elixir
[PartB.solve(input_p2t), PartB.solve_regex(input_p2t)]
```

```elixir
[PartB.solve(input), PartB.solve_regex(input)]
```

<!-- livebook:{"offset":2497,"stamp":{"token":"XCP.F35_credMc9FOwOvDfvl0p44hA1r7paC7_DDlOOPtH5z5w1fvEukR4x4_jCrxmIJixkZ8wD_nMaO8cItEzeJn6hPr0ODoDb_ZP98SA","version":2}} -->
